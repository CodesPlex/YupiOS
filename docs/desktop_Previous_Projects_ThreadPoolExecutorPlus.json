{"data": "# ThreadPoolExecutorPlus\n\n.VERSION | LICENCE | VERSION | PUBLISH | BUILD \n:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:\n![fury](https://badge.fury.io/py/ThreadPoolExecutorPlus.svg) | ![licence](https://img.shields.io/github/license/GoodManWEN/ThreadPoolExecutorPlus) | ![pyversions](https://img.shields.io/pypi/pyversions/ThreadPoolExecutorPlus.svg) | ![Publish](https://github.com/GoodManWEN/ThreadPoolExecutorPlus/workflows/Publish/badge.svg) | ![Build](https://github.com/GoodManWEN/ThreadPoolExecutorPlus/workflows/Build/badge.svg)\n\nThis package provides you a duck typing of concurrent.futures.ThreadPoolExecutor , which has the very similar api and could fully replace ThreadPoolExecutor in your code.\n\nThe reason why this pack exists is we would like to solve several specific pain spot of memory control in native python one. \n\n## Feature\n- Fully replaceable with concurrent.futures.ThreadPoolExecutor , for example in asyncio.\n- Whenever submit a new task , executor will perfer to use existing idle thread rather than create a new one.\n- Executor will automatically shrink itself duriung leisure time in order to achieve higher efficiency and less memory.\n\n## Install\n\n    pip install ThreadPoolExecutorPlus\n\n## Usage\nSame api as concurrent.futures.ThreadPoolExecutor , with some more control function added: \n\n##### set_daemon_opts(min_workers = None, max_workers = None, keep_alive_time = None)\n    \n&emsp;&emsp;&emsp; In order to guarantee same api interface , new features should be modfied after object created.  \n&emsp;&emsp;&emsp; Could change minimum/maximum activate worker num , and set after how many seconds will the  \n&emsp;&emsp;&emsp; idle thread terminated.   \n&emsp;&emsp;&emsp; By default , min_workers = 4 , max_workers = 16 times cpu_core count on windows and 32x on  \n&emsp;&emsp;&emsp; linux , keep_alive_time = 100s. \n\n## Example\n\nVery the same code in official doc [#threadpoolexecutor-example](https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor-example) , with executor replaced:\n```Python3\n# requests_test.py\nimport concurrent.futures\nimport ThreadPoolExecutorPlus\nimport urllib.request\n\nURLS = ['http://www.foxnews.com/',\n        'http://www.cnn.com/',\n        'http://europe.wsj.com/',\n        'http://www.bbc.co.uk/',\n        'http://some-made-up-domain.com/']\n\ndef load_url(url, timeout):\n    with urllib.request.urlopen(url, timeout=timeout) as conn:\n        return conn.read()\n\nwith ThreadPoolExecutorPlus.ThreadPoolExecutor(max_workers=5) as executor:\n    # Try modify deamon options\n    executor.set_daemon_opts(min_workers = 2 , max_workers = 10 , keep_alive_time = 60)\n    future_to_url = {executor.submit(load_url, url, 60): url for url in URLS}\n    for future in concurrent.futures.as_completed(future_to_url):\n        url = future_to_url[future]\n        try:\n            data = future.result()\n        except Exception as exc:\n            print('%r generated an exception: %s' % (url, exc))\n        else:\n            print('%r page is %d bytes' % (url, len(data)))\n```\n\nSame code in offcial doc [#executing-code-in-thread-or-process-pools](https://docs.python.org/3/library/asyncio-eventloop.html#executing-code-in-thread-or-process-pools) with executor replaced:\n```Python3\n# Runs on python version above 3.7\nimport asyncio\nimport ThreadPoolExecutorPlus\n\ndef blocking_io():\n    with open('/dev/urandom', 'rb') as f:\n        return f.read(100)\n\ndef cpu_bound():\n    return sum(i * i for i in range(10 ** 7))\n\nasync def main():\n    loop = asyncio.get_running_loop()\n\n    with ThreadPoolExecutorPlus.ThreadPoolExecutor() as pool:\n        result1 = await loop.run_in_executor(\n            pool, blocking_io)\n        result2 = await loop.run_in_executor(\n            pool, cpu_bound)\n        print('custom thread pool', result1)\n        print('custom thread pool', result2)\n\nasyncio.run(main())\n```\n\nFeature demo:\n```Python3\n# feature_demo.py\nfrom ThreadPoolExecutorPlus import ThreadPoolExecutor\nimport time , datetime\n\ndef log(stmt , name = 'MAIN THREAD'):\n    print(f\"[{datetime.datetime.strftime(datetime.datetime.now() , '%Y-%m-%d %H:%M:%S')}][{name}] {stmt}\")\n\ndef some_func(arg):\n    # does some heavy lifting\n    # outputs some results\n    log(f\"New task triggered in sub thread , sleep {arg} seconds.\" , 'SUB THREAD ')\n    time.sleep(arg)\n    log(f\"Terminated.\" , 'SUB THREAD ') \n    return arg\n\nwith ThreadPoolExecutor() as executor:\n    log(f\"max_workers = {executor._max_workers}\")\n    log(f\"min_workers = {executor._min_workers}\")\n    log(\"====================================================\")\n\n    # We continuously generate tasks which blocks 0.5s every 1 second.\n    # Observe its thread control behaviour.\n    # Thus find it perfer to reuse existing threads.\n    log(\"Reuse test:\")\n    for _ in range(10):\n        executor.submit(some_func , 0.5)\n        time.sleep(1)\n        log(f\"Current poll size = {len(executor._threads)}\")\n\n    log(\"====================================================\")\n\n    # Observe the behaviour after all task done.\n    # Controler will make fast reaction after new options set ,\n    # and automaticlly shrink no-use threads.\n    log(\"Shrink test:\")\n    log(\"Adjust timeout time to 10 seconds.\")\n    executor.set_daemon_opts(min_workers = 2 , max_workers = 10 , keep_alive_time = 10)\n    for _ in range(10):\n        executor.submit(some_func , 3)\n        time.sleep(0.01)\n    log(\"10 new tasks created.\")\n\n\n    time.sleep(3)\n    log(\"All task done.\")\n    \n    for _ in range(15):\n        log(f\"Current poll size = {len(executor._threads)} , {_ + 1}s passed.\")\n        time.sleep(1)\n```\n"}