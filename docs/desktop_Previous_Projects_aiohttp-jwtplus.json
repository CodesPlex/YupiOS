{"data": "# aiohttp-jwtplus\n\n.VERSION | LICENCE | VERSION | PUBLISH | BUILD\n:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:\n![fury](https://badge.fury.io/py/aiohttp-jwtplus.svg) | ![licence](https://img.shields.io/github/license/GoodManWEN/aiohttp-jwtplus) | ![pyversions](https://img.shields.io/pypi/pyversions/aiohttp-jwtplus.svg) | ![Publish](https://github.com/GoodManWEN/aiohttp-jwtplus/workflows/Publish/badge.svg) | ![build](https://github.com/GoodManWEN/aiohttp-jwtplus/workflows/Build/badge.svg)\n\nAiohttp middleware and helper utils for working with JSON web token(signature).\nAdded a post router for improving security level of SPAs &amp; auto refresh secrets. \n\n- Secret auto refresh.\n- Totally separated content.\n- Works on Python3.7+\n\n## Requirements\n- [Aiohttp >= 2.3.5](https://github.com/aio-libs/aiohttp)\n- [PyJWT](https://github.com/jpadilla/pyjwt)\n\n## Install\n\n    pip install aiohttp-jwtplus\n\n## Usage\n- You need to create a SecretManager object ,which manages informations(secret \\ scheme \\ algorithm \\ exp_interval \\ auto_refresh_interval etc.) about jwt first.\n- Then you need to create a JWTHelper ,in whose slots you can  definite your business logic ,such as where you get token from ,what you do in identify process etc. If you dont pass them in ,JWTHelper will provides you a basic version of token_getter & identifier ,which simplely gets token from headers['Authorization'] value and then check out if decoded dictionary has key value 'username'.\n- Finally you can create aiohttp.web.Application and pass middlewares in . It's a necessary condition to passin pre_jwt_identifier() and post_jwt_router() in order if you would like to activate post router. It's no need to register middleware via decorator first.\n\n## Behaviors of routing under different authorization\npath | remarks | authorized destination |  unauthorized destination\n-|-|-|-\n/index.html | Entry of main functional SPA | /index.html | /login.html\n/login.html | Entry of login page. Independent SPA | /index.html | /login.html\n/login_api  | Login api , one in jwt whitelist. | /login_api | /login_api\n/setattr_api | One of protected apis. | /setattr_api | 403 or 401\n/404        | Undefined page | /index.html | /login.html\n\n*/\\* Status code 404 would be handled in SPA \\*/*\n\n## Example\n`server_basic.py` \n\\# here's a basic aiohttp hello-world server with four kinds of routing requirement respectively.\n\n```Python3\nfrom aiohttp import web\n\nroutes = web.RouteTableDef()\n\n@routes.get('/index.html')\nasync def main_spa_page(request):\n    return web.Response(text=\"this is index.html\")\n\n@routes.get('/login.html')\nasync def login_spa_page(request):\n    return web.Response(text=\"this is login.html\")\n\n@routes.get('/authentication')\nasync def loginapi(request):\n    return web.Response(text=\"loginapi called\")\n\n@routes.get('/setattr')\nasync def setattr(request):\n    return web.Response(text= 'this is a procted api')\n\napp = web.Application(middlewares=[])\napp.add_routes(routes)\nweb._run_app(app)\n```\n\n`server.py` \n\\# Add several lines to easily start a server with jwtplus-plugin.\n```Python3\nimport asyncio\nfrom aiohttp import web\nfrom aiohttp_jwtplus import (\n    SecretManager,\n    JWTHelper,\n    basic_identifier,\n    basic_token_getter,\n    show_request_info\n)\n\nroutes = web.RouteTableDef()\n\n@routes.get('/index.html')\nasync def main_spa_page(request):\n    show_request_info(request)\n    return web.Response(text=\"this is index.html\")\n\n@routes.get('/login.html')\nasync def login_spa_page(request):\n    show_request_info(request)\n    return web.Response(text=\"this is login.html\")\n\n@routes.get('/authentication')\nasync def loginapi(request):\n    show_request_info(request)\n    return web.Response(text=\"loginapi called\")\n\n@routes.get('/setattr')\nasync def setattr(request):\n    show_request_info(request)\n    return web.Response(text= 'this is a procted api')\n\nsecret_manager = SecretManager( secret = 'testsecret' ,    # default empty, will generate a random string.\n                                refresh_interval = '30d' , # default 0 ,represents secret auto refresh disabled. Accept string or int \n                                scheme = \"Bearer\" ,        # default.\n                                algorithm = 'HS256' ,      # default.\n                                exptime = '30d' ,          # default.\n                                )\n\njwt = JWTHelper(\n            unauthorized_return_route = '/login.html' , \n            # this's an exception which means if you've alreadly logined ,you cannot access to this page. \n            unauthorized_return_route_handler = login_spa_page,\n            authorized_return_page_handler = main_spa_page,\n            secret_manager = secret_manager , \n            token_getter = basic_token_getter,  # default\n            identifier =  basic_identifier ,    # default\n            whitelist = ('/authentication', ) , # must be a tuple ,accepts regular expresion.\n            protected_apis = ['/setattr',] \n        )\n\napp = web.Application(middlewares=[ \n                jwt.pre_jwt_identifier(),\n                jwt.post_jwt_router(),\n                                ])\napp.add_routes(routes)\nloop = asyncio.get_event_loop()\nloop.create_task(secret_manager.auto_refresh())\n# Explicit trigger eventloop since we starts a secret-auto-refresh thread.  \nloop.run_until_complete(web._run_app(app))\n```\n\n`client.py` \n\\# For a quick test with python pretended frontend.\n```Python3\nimport asyncio\nfrom aiohttp import ClientSession \nfrom aiohttp_jwtplus import (\n    SecretManager,\n    JWTHelper,\n    basic_identifier,     # it's a coroutine\n    basic_token_getter,   # it's a coroutine\n    show_request_info     # print function\n)\n\n\nsecret_manager = SecretManager( secret = 'testsecret' ,    # default empty, will generate a random string.\n                                refresh_interval = 0 ,     # default 0 , no auto refresh.\n                                algorithm = 'HS256' ,      # default.\n                                exptime = '30d' ,          # default.\n                                )\n\nurl_pattern = 'http://localhost:8080{}'\nurl_exts = [    '/index.html' ,\n                '/login.html' ,\n                '/authentication',\n                '/setattr',\n                '/404',\n                ]\n                \n# Simulate you've alreadly got token feedback from server.\n# If you would like to generate token(without scheme) ,it accepts a dictionary\n# and items in which would be updated to jwt source payload. \njwt = secret_manager.encode({'username':'jacky'})\n\nheaders = {\n    'Authorization': \"Bearer \" + jwt\n}\n\nasync def main():\n    async with ClientSession() as session:\n        print(f'{\"#\"*22}\\nWith authentication')\n        for urlext in url_exts:\n            async with session.get(url_pattern.format(urlext) , headers = headers) as response:\n                text = await response.text()\n                print(f\"called {urlext} ,\\n\\tget statuscode {response.status} , \\n\\treturn text \\\"{text}\\\"\")\n        print(f'{\"#\"*22}\\nWithout authentication')\n        for urlext in url_exts:\n            async with session.get(url_pattern.format(urlext) , headers={'Authorization':'None'}) as response:\n                text = await response.text()\n                print(f\"called {urlext} ,\\n\\tget statuscode {response.status} , \\n\\treturn text \\\"{text}\\\"\")\n\nasyncio.run(main())\n\n```\n\n`modify_identifier.py` \n\\# Self-modified identifier & token_getter.\n```Python3\nfrom aiohttp import web\nfrom aiohttp_jwtplus import (\n    SecretManager,\n    JWTHelper\n)\n\nasync def identifier_mod(payload):\n    '''\n    An identifier accepts a payload(as dictionary of jwt decoded result),\n    and whose return value will be stored as one of request's property named 'auth_carry'\n    If you would like to make identification fail in middleware(before handle requests),\n    return False.\n    You don't need to worry about exceptions.\n    '''\n    if 'username' in payload:\n        return payload['username']\n    else:\n        return False\n\n@routes.get('/index.html')\nasync def authorised(request):\n    username = request['auth_carry']['username']\n    if username == 'admin':\n        return web.Response(text = 'pass')\n    else:\n        return web.Response(text = 'fail')\n\nsecret_manager = SecretManager( secret = 'testsecret' )\n\njwt = JWTHelper(\n            unauthorized_return_route = '' , \n            unauthorized_return_route_handler = authorised,\n            authorized_return_page_handler = authorised,\n            secret_manager = secret_manager \n        )\n        \napp = web.Application(middlewares=[ \n        jwt.pre_jwt_identifier(),\n        jwt.post_jwt_router(),\n                        ])\napp.add_routes(routes)\nweb.run_app(app)\n\n# Then you shall start a simulate client and encode a header with jwt authenrized payload with 'usernaem : admin' in it\n# and test if you got the corret response.\n```\n"}