{"data": "# aioredlock-py\n![fury](https://img.shields.io/pypi/v/aioredlock-py.svg)\n![licence](https://img.shields.io/github/license/GoodManWEN/aioredlock-py)\n![pyversions](https://img.shields.io/pypi/pyversions/aioredlock-py.svg)\n![Publish](https://github.com/GoodManWEN/aioredlock-py/workflows/Publish/badge.svg)\n![Build](https://github.com/GoodManWEN/aioredlock-py/workflows/Build/badge.svg)\n![Docs](https://readthedocs.org/projects/aioredlock-py/badge/?version=latest)\n\nSecure and efficient distributed locks (Redisson like) implemetation. Ensure efficient performance with biased locking's implementation, can load more than 1k/s of concurrent requests with default parameter settings.\n\n## Requirements\n- aioredis>=2.0.0\n\n## Install\n\n    pip install aioredlock-py\n\n## Feature\n- Ensure reliability with context manager.\n- Use lua scripts to ensure atomicity on lock release.\n- Notification prompt you to cancel the following execution if acquisition fails\n- Reliable in high concurrency.\n\n## Documentation\nhttps://aioredlock-py.readthedocs.io\n\n## Basic usage\n```python\nimport asyncio\nimport aioredis\nfrom aioredlock_py import Redisson\n\nasync def single_thread(redis):\n    for _ in range(10):\n        async with Redisson(redis, key=\"no1\") as lock:\n            if not lock:\n                # If the lock still fails after several attempts, `__aenter__` \n                # will return None to prompt you to cancel the following execution\n                return 'Do something, failed to acquire lock' # raise ...\n            # else \n            # Service logic protected by Redisson\n            await redis.incr(\"foo\")\n\nasync def test_long_term_occupancy(redis):\n    async with Redisson(redis, key=\"no1\", ex=10) as lock:\n        if not lock: return;\n        # Service logic protected by Redisson\n        await redis.set(\"foo\", 0)\n        # By default, a lock is automatically released if no action is \n        # taken for 20 seconds after redisson holds it. Let's assume that \n        # your service logic takes a long time (30s in this case) to process,\n        # you don't need to worry about it causing chaos, because there's \n        # background threads help you automatically renew legally held locks.\n        await asyncio.sleep(30)\n        await redis.incr(\"foo\")\n\n\nasync def main():\n    redis = aioredis.from_url(\"redis://localhost\")\n    await redis.delete(\"redisson:no1\")\n    await redis.set(\"foo\", 0)\n    await asyncio.gather(*(single_thread(redis) for _ in range(20)))\n    assert int(await redis.get(\"foo\")) == 200\n    # await test_long_term_occupancy(redis)\n\nasyncio.run(main())\n```\n"}