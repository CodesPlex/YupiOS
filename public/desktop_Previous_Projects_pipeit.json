{"data": "# pipeit\n\n.VERSION | LICENCE | VERSION | PUBLISH | BUILD\n:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:|:-------------------------:\n![fury](https://badge.fury.io/py/pipeit.svg)  |  ![licence](https://img.shields.io/github/license/GoodManWEN/pipeit) | ![pyversions](https://img.shields.io/pypi/pyversions/pipeit.svg) | ![Publish](https://github.com/GoodManWEN/pipeit/workflows/Publish/badge.svg) | ![Build](https://github.com/GoodManWEN/pipeit/workflows/Build/badge.svg)\n\n\nLet's use python functional programming like Unix pipe! \n\nInspired by [abersheeran/only-pipe](https://github.com/abersheeran/only-pipe) , [czheo/syntax_sugar_python](https://github.com/czheo/syntax_sugar_python) , [pipetools](https://pypi.org/project/pipetools/)\n\n## Install\n\n    pip install pipeit\n\n## Usage\n- Statements start with `PIPE` and end with `END` **OR** you can even ellipsis them.\n- There're only two objects(`PIPE` & `END`) and three types(`Filter` ,`Map` & `Reduce`) in namespace, so feel free to use `from pipeit import *`.\n- Convert filter into tuple or capital the first letter, e.g. `map(lambda x:x + 1) => (map , lambda x:x + 1)` or `Map(lambda x:x + 1)` , however **DO NOT MIX USE THEM**.\n- It'll be 10% ~ 20% faster using the original python functional way than using these wrappers. \n\n## Example\n\n```Python\n>>> from pipit import PIPE , END , Map , Filter , Reduce\n\n>>> data = PIPE | range(10) | (map , lambda x:x + 1) | (map , str) | list | END\n>>> data\n['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\n\n# (map , lambda x:x + 1) equals to Map(lambda x:x + 1)\n>>> func = lambda x: PIPE | range(x) | Map(lambda x:x + 1) | Map(str) | list | END\n>>> func(10)\n['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\n```\n\nOr you may want a more easy use.\n```Python\n>>> range(10) | Filter(lambda x:x<5) | list\n[0, 1, 2, 3, 4]\n\n>>> for _ in range(3) | Map(str):\n        print(repr(_))\n\n\n'0'\n'1'\n'2'\n```\n\nCode timer updated in version 2.0, you can easily detect the execution time of code blocks or statements.\n```Python\nfrom pipit import *\nfrom functools import reduce\n\nfoo = list(range(100))\nfor _ in timeit(1e6): # which means loop for 1m times\n    bar = foo | Filter(lambda x: x%3) | Map(lambda x: 10*x) | Reduce(lambda x, y: x+y) | int\n\nwith timeit(): # a handwritten for loop is required under context manager mode\n    for _ in range(int(1e6)):\n        bar = reduce(lambda x, y: x+y, map(lambda x: 10*x, filter(lambda x: x%3, foo)))\n\n# output: \n# [line 5][approximate] time cost / loop: 9.8967234\u03bcs\n# [line 8][exact] time cost: 7.0519098s\n```\n"}